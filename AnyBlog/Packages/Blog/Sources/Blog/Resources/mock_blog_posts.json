{
  "kind": "blogger#postList",
  "nextPageToken": "CgkIChig16fF7TAQ1s6G0oXamvZeGAA",
  "items": [
    {
      "kind": "blogger#post",
      "id": "1193431587290315384",
      "blog": {
        "id": "6839959377168934742"
      },
      "published": "2024-10-22T08:09:00-07:00",
      "updated": "2024-10-22T08:09:42-07:00",
      "url": "http://techinterviewpro.blogspot.com/2024/10/swift-combine.html",
      "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/1193431587290315384",
      "title": "Swift এর Combine ফ্রেমওয়ার্ক নিয়ে পরিচিতি: অ্যাসিঙ্ক্রোনাস ইভেন্ট হ্যান্ডলিংয়ের একটি আধুনিক পদ্ধতি",
      "content": "\u003cp\u003e&nbsp;iOS ডেভেলপমেন্টে অ্যাসিঙ্ক্রোনাস প্রোগ্রামিং একটি গুরুত্বপূর্ণ বিষয়, বিশেষ করে যখন নেটওয়ার্ক রিকোয়েস্ট, টাইমার, ইউজার ইন্টারফেস আপডেট, এবং ডেটা স্ট্রিমের সাথে কাজ করা হয়। \u003cstrong\u003eCombine ফ্রেমওয়ার্ক\u003c/strong\u003e এর সাথে, অ্যাপল অ্যাসিঙ্ক্রোনাস ইভেন্ট এবং ডেটা স্ট্রিমগুলিকে ডিক্লারেটিভ উপায়ে হ্যান্ডল করার জন্য একটি শক্তিশালী টুল সরবরাহ করেছে।\u003c/p\u003e\u003cp\u003eএই ব্লগ পোস্টে, আমরা \u003cstrong\u003eCombine ফ্রেমওয়ার্ক\u003c/strong\u003e এর বেসিক কনসেপ্ট গুলো সম্পর্কে জানবো, কিভাবে এটি কাজ করে এবং কিছু ব্যবহারিক উদাহরণ দেবো যাতে আপনি সহজে শুরু করতে পারেন।\u003c/p\u003e\u003ch2\u003eCombine কী?\u003c/h2\u003e\u003cp\u003eCombine হল অ্যাপলের \u003cstrong\u003eReactive Programming\u003c/strong\u003e ফ্রেমওয়ার্ক যা \u003cstrong\u003eiOS 13\u003c/strong\u003e এ ইন্ট্রোডিউস করা হয়। এটি ডেভেলপারদের ইউজার ইনপুট, নোটিফিকেশন, টাইমার এবং নেটওয়ার্ক রেসপন্সের মতো ইভেন্ট গুলো ডিক্লারেটিভ এবং স্ট্রিমলাইনড উপায়ে হ্যান্ডল করতে দেয়।\u003c/p\u003e\u003cp\u003eCombine এর প্রধান লক্ষ্য হলো অ্যাসিঙ্ক্রোনাস কাজ যেমন নেটওয়ার্ক রিকোয়েস্ট চেইনিং, নতুন ডেটা সহ UI আপডেট করা, অথবা জটিল স্টেট ম্যানেজমেন্টকে আরও সহজ করা। এটি \u003cstrong\u003ePublishers\u003c/strong\u003e, \u003cstrong\u003eSubscribers\u003c/strong\u003e, এবং \u003cstrong\u003eOperators\u003c/strong\u003e ব্যবহার করে অ্যাসিঙ্ক্রোনাস ডেটা স্ট্রিমের সাথে কাজ করে।\u003c/p\u003e\u003ch3\u003eCombine কেন ব্যবহার করবেন?\u003c/h3\u003e\u003cp\u003eCombine আসার আগে, iOS ডেভেলপাররা মূলত কম্প্লিশন হ্যান্ডলার, ডেলিগেশন, অথবা \u003cstrong\u003eRxSwift\u003c/strong\u003e এর মতো থার্ড-পার্টি ফ্রেমওয়ার্ক ব্যবহার করতেন। Combine এর কিছু উল্লেখযোগ্য সুবিধা হলো:\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eDeclarative Syntax\u003c/strong\u003e: ডেটা ফ্লো এবং ট্রান্সফরমেশনগুলোকে একটি পরিষ্কার এবং সহজ রিডেবল উপায়ে ডিফাইন করা যায়।\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eFirst-Party Support\u003c/strong\u003e: অ্যাপলের ইকোসিস্টেমে যেমন SwiftUI, \u003ccode\u003eURLSession\u003c/code\u003e, এবং \u003ccode\u003eNotificationCenter\u003c/code\u003e এর সাথে পূর্ণ ইন্টিগ্রেশন রয়েছে।\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eLess Boilerplate\u003c/strong\u003e: অ্যাসিঙ্ক্রোনাস টাস্ক হ্যান্ডলিংয়ের জন্য প্রচুর কলব্যাক এবং স্টেট ম্যানেজমেন্ট কোডের প্রয়োজন কমিয়ে আনে।\u003c/li\u003e\u003c/ol\u003e\u003chr /\u003e\u003ch2\u003eCombine এর মূল ধারণা\u003c/h2\u003e\u003ch3\u003e১. \u003cstrong\u003ePublisher\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003e\u003ccode\u003ePublisher\u003c/code\u003e হলো একটি ডেটা সোর্স যা সময়ের সাথে সাথে বিভিন্ন মান এমিট করে। পাবলিশার একাধিক মান অথবা একটি মাত্র মান পাঠাতে পারে এবং একটি কমপ্লিশন বা এরর সিগনাল করতে পারে।\u003c/p\u003e\u003cp\u003eCombine এ কয়েকটি বিল্ট-ইন পাবলিশার রয়েছে:\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eURLSession.DataTaskPublisher\u003c/code\u003e (নেটওয়ার্ক রিকোয়েস্টের জন্য)\u003c/li\u003e\u003cli\u003e\u003ccode\u003eNotificationCenter.Publisher\u003c/code\u003e (নোটিফিকেশন হ্যান্ডল করার জন্য)\u003c/li\u003e\u003cli\u003e\u003ccode\u003eJust\u003c/code\u003e (একটি মাত্র মান এমিট করার জন্য)\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003e২. \u003cstrong\u003eSubscriber\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eSubscriber\u003c/code\u003e হল সেই অবজেক্ট যা পাবলিশারের এমিট করা মানগুলো শোনে এবং সেই অনুযায়ী কাজ করে। সাবস্ক্রাইবার পাবলিশারের পাঠানো মান, কমপ্লিশন বা এরর এর প্রতিক্রিয়া জানায়।\u003c/p\u003e\u003ch3\u003e৩. \u003cstrong\u003eOperator\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eOperator\u003c/code\u003e ডেটা এমিশনগুলোকে মডিফাই বা ট্রান্সফর্ম করার জন্য ব্যবহৃত হয়। সাধারণ অপারেটরগুলোর মধ্যে ম্যাপিং, ফিল্টারিং, এবং ডেটা স্ট্রিম একত্রিত করার কাজ করে।\u003c/p\u003e\u003ch3\u003e৪. \u003cstrong\u003eSubscription\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003e\u003ccode\u003eSubscription\u003c/code\u003e পাবলিশার এবং সাবস্ক্রাইবারের মধ্যে একটি সংযোগ তৈরি করে। এটি সাবস্ক্রাইবারকে পাবলিশার থেকে ডেটা রিকোয়েস্ট করার অনুমতি দেয় এবং সাবস্ক্রিপশন বাতিল করার জন্য ব্যবহৃত হয়।\u003c/p\u003e\u003chr /\u003e\u003ch2\u003eSwift প্রজেক্টে Combine সেটআপ করা\u003c/h2\u003e\u003cp\u003eচলুন Combine এর বেসিক ওয়ার্কফ্লো এবং একটি উদাহরণ নিয়ে কাজ করি যেখানে আমরা নেটওয়ার্ক থেকে ডেটা ফেচ করি এবং UI তে আপডেট করি।\u003c/p\u003e\u003ch3\u003eধাপ ১: বেসিক Combine ওয়ার্কফ্লো\u003c/h3\u003e\u003cp\u003eএখানে আমরা একটি সাধারণ \u003ccode\u003eURLSession\u003c/code\u003e নেটওয়ার্ক রিকোয়েস্ট তৈরি করবো যা JSON ডেটা API থেকে ফেচ করবে এবং ViewModel এ সংরক্ষণ করবে। SwiftUI এর মাধ্যমে ডেটা UI তে প্রদর্শিত হবে।\u003c/p\u003e\u003ch4\u003eModel\u003c/h4\u003e\u003cp\u003eধরি আমাদের একটি মডেল আছে যা JSON API এর রেসপন্স রিপ্রেজেন্ট করে:\u003c/p\u003e\u003cpre class=\"!overflow-visible\"\u003e\u003cdiv class=\"contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950\"\u003e\u003cdiv class=\"overflow-y-auto p-4\" dir=\"ltr\"\u003e\u003ccode class=\"!whitespace-pre hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePost\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eCodable\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eIdentifiable\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e id: \u003cspan class=\"hljs-type\"\u003eInt\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e title: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e body: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/div\u003e\u003c/div\u003e\u003c/pre\u003e\u003ch4\u003eViewModel\u003c/h4\u003e\u003cp\u003eএবার আমরা Combine ব্যবহার করে একটি ViewModel তৈরি করবো। এই ViewModel API থেকে পোস্টগুলো ফেচ করবে এবং একটি অ্যারে হিসেবে সংরক্ষণ করবে:\u003c/p\u003e\u003cpre class=\"!overflow-visible\"\u003e\u003cdiv class=\"contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950\"\u003e\u003cdiv class=\"flex items-center text-token-text-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9 bg-token-sidebar-surface-primary dark:bg-token-main-surface-secondary\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Combine\u003c/div\u003e\u003cdiv class=\"overflow-y-auto p-4\" dir=\"ltr\"\u003e\u003ccode class=\"!whitespace-pre hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e SwiftUI\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePostsViewModel\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eObservableObject\u003c/span\u003e {\n    \u003cspan class=\"hljs-meta\"\u003e@Published\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e posts: [\u003cspan class=\"hljs-type\"\u003ePost\u003c/span\u003e] \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e [] \u003cspan class=\"hljs-comment\"\u003e// Observable property\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e cancellables \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eSet\u003c/span\u003e&lt;\u003cspan class=\"hljs-type\"\u003eAnyCancellable\u003c/span\u003e&gt;() \u003cspan class=\"hljs-comment\"\u003e// Holds the subscriptions\u003c/span\u003e\n    \n    \u003cspan class=\"hljs-comment\"\u003e// Fetch data from API\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetchPosts\u003c/span\u003e() {\n        \u003cspan class=\"hljs-keyword\"\u003eguard\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e url \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eURL\u003c/span\u003e(string: \u003cspan class=\"hljs-string\"\u003e\"https://jsonplaceholder.typicode.com/posts\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e { \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e }\n        \n        \u003cspan class=\"hljs-type\"\u003eURLSession\u003c/span\u003e.shared.dataTaskPublisher(for: url)\n            .map { \u003cspan class=\"hljs-variable\"\u003e$0\u003c/span\u003e.data } \u003cspan class=\"hljs-comment\"\u003e// Extract the data\u003c/span\u003e\n            .decode(type: [\u003cspan class=\"hljs-type\"\u003ePost\u003c/span\u003e].\u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e, decoder: \u003cspan class=\"hljs-type\"\u003eJSONDecoder\u003c/span\u003e()) \u003cspan class=\"hljs-comment\"\u003e// Decode the JSON into [Post]\u003c/span\u003e\n            .replaceError(with: []) \u003cspan class=\"hljs-comment\"\u003e// Replace error with an empty array\u003c/span\u003e\n            .receive(on: \u003cspan class=\"hljs-type\"\u003eDispatchQueue\u003c/span\u003e.main) \u003cspan class=\"hljs-comment\"\u003e// Ensure we update UI on the main thread\u003c/span\u003e\n            .sink { [\u003cspan class=\"hljs-keyword\"\u003eweak\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e] posts \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n                \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e.posts \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e posts \u003cspan class=\"hljs-comment\"\u003e// Assign the result to the published property\u003c/span\u003e\n            }\n            .store(in: \u003cspan class=\"hljs-operator\"\u003e&amp;\u003c/span\u003ecancellables) \u003cspan class=\"hljs-comment\"\u003e// Store the subscription to prevent premature cancellation\u003c/span\u003e\n    }\n}\n\u003c/code\u003e\u003c/div\u003e\u003c/div\u003e\u003c/pre\u003e\u003ch4\u003eব্যাখ্যা:\u003c/h4\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003ePublisher\u003c/strong\u003e: \u003ccode\u003eURLSession.shared.dataTaskPublisher(for:)\u003c/code\u003e হচ্ছে পাবলিশার যা নেটওয়ার্ক রিকোয়েস্ট থেকে ডেটা এমিট করে।\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eOperator Chain\u003c/strong\u003e: এখানে আমরা \u003ccode\u003emap\u003c/code\u003e দিয়ে ডেটা এক্সট্র্যাক্ট করি, \u003ccode\u003edecode\u003c/code\u003e দিয়ে JSON কে Swift অবজেক্টে রূপান্তর করি এবং \u003ccode\u003ereplaceError\u003c/code\u003e দিয়ে এরর হ্যান্ডল করি।\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eSubscriber\u003c/strong\u003e: \u003ccode\u003esink\u003c/code\u003e সাবস্ক্রাইবার হিসেবে কাজ করে, যা ডেটা শোনে এবং সেটিকে \u003ccode\u003eposts\u003c/code\u003e প্রপার্টিতে অ্যাসাইন করে।\u003c/li\u003e\u003c/ol\u003e\u003ch4\u003eView\u003c/h4\u003e\u003cp\u003eএখন আমরা \u003ccode\u003eposts\u003c/code\u003e প্রপার্টিকে SwiftUI ভিউতে বাইন্ড করবো:\u003c/p\u003e\u003cpre class=\"!overflow-visible\"\u003e\u003cdiv class=\"contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950\"\u003e\u003cdiv class=\"overflow-y-auto p-4\" dir=\"ltr\"\u003e\u003ccode class=\"!whitespace-pre hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e SwiftUI\n\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePostsView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-meta\"\u003e@StateObject\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e viewModel \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003ePostsViewModel\u003c/span\u003e() \u003cspan class=\"hljs-comment\"\u003e// The ViewModel\u003c/span\u003e\n    \n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e body: \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003eNavigationView\u003c/span\u003e {\n            \u003cspan class=\"hljs-type\"\u003eList\u003c/span\u003e(viewModel.posts) { post \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e\n                \u003cspan class=\"hljs-type\"\u003eVStack\u003c/span\u003e(alignment: .leading) {\n                    \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(post.title)\n                        .font(.headline)\n                    \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(post.body)\n                        .font(.subheadline)\n                }\n            }\n            .navigationTitle(\u003cspan class=\"hljs-string\"\u003e\"Posts\"\u003c/span\u003e)\n            .onAppear {\n                viewModel.fetchPosts() \u003cspan class=\"hljs-comment\"\u003e// Fetch data when the view appears\u003c/span\u003e\n            }\n        }\n    }\n}\n\u003c/code\u003e\u003c/div\u003e\u003c/div\u003e\u003c/pre\u003e\u003ch3\u003eধাপ ২: Publisher থেকে Subscriber এ কানেকশন তৈরি করা\u003c/h3\u003e\u003cp\u003eএখানে \u003ccode\u003esink\u003c/code\u003e অপারেটরটি গুরুত্বপূর্ণ কারণ এটি পাবলিশার থেকে ডেটা \"সাবস্ক্রাইব\" করে এবং আসা ডেটা হ্যান্ডল করে। উপরোক্ত ViewModel এ, \u003ccode\u003esink\u003c/code\u003e অপারেটর নেটওয়ার্ক থেকে রেসপন্স শোনে এবং \u003ccode\u003eposts\u003c/code\u003e প্রপার্টিতে ডেটা অ্যাসাইন করে, যার ফলে SwiftUI এর মাধ্যমে UI স্বয়ংক্রিয়ভাবে আপডেট হয়।\u003c/p\u003e\u003chr /\u003e\u003ch2\u003eনোটিফিকেশন হ্যান্ডলিং Combine এর মাধ্যমে\u003c/h2\u003e\u003cp\u003eনেটওয়ার্ক রিকোয়েস্টের পাশাপাশি, Combine অন্যান্য ইভেন্ট-বেইসড API যেমন \u003ccode\u003eNotificationCenter\u003c/code\u003e এর সাথে ভালোভাবে কাজ করে। আপনি নোটিফিকেশনকে পাবলিশার হিসেবে পর্যবেক্ষণ করতে পারেন এবং ডিক্লারেটিভ উপায়ে এর উপর প্রতিক্রিয়া জানাতে পারেন।\u003c/p\u003e\u003ch3\u003eউদাহরণ: নোটিফিকেশন পর্যবেক্ষণ\u003c/h3\u003e\u003cp\u003eআমরা একটি কাস্টম নোটিফিকেশন পর্যবেক্ষণ করবো এবং সেই অনুযায়ী SwiftUI ভিউ আপডেট করবো।\u003c/p\u003e\u003cpre class=\"!overflow-visible\"\u003e\u003cdiv class=\"contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative bg-token-sidebar-surface-primary dark:bg-gray-950\"\u003e\u003cdiv class=\"overflow-y-auto p-4\" dir=\"ltr\"\u003e\u003ccode class=\"!whitespace-pre hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e Combine\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e SwiftUI\n\n\u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNotificationViewModel\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eObservableObject\u003c/span\u003e {\n    \u003cspan class=\"hljs-meta\"\u003e@Published\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e message: \u003cspan class=\"hljs-type\"\u003eString\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Waiting for notification...\"\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e cancellable: \u003cspan class=\"hljs-type\"\u003eAnyCancellable\u003c/span\u003e?\n\n    \u003cspan class=\"hljs-keyword\"\u003einit\u003c/span\u003e() {\n        \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e notification \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eNotification\u003c/span\u003e.\u003cspan class=\"hljs-type\"\u003eName\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"MyNotification\"\u003c/span\u003e)\n        cancellable \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eNotificationCenter\u003c/span\u003e.default.publisher(for: notification)\n            .map { \u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Notification received!\"\u003c/span\u003e }\n            .assign(to: \\.message, on: \u003cspan class=\"hljs-keyword\"\u003eself\u003c/span\u003e)\n    }\n}\n\n\u003cspan class=\"hljs-keyword\"\u003estruct\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eNotificationView\u003c/span\u003e: \u003cspan class=\"hljs-title class_\"\u003eView\u003c/span\u003e {\n    \u003cspan class=\"hljs-meta\"\u003e@StateObject\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eprivate\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e viewModel \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eNotificationViewModel\u003c/span\u003e()\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e body: \u003cspan class=\"hljs-keyword\"\u003esome\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eView\u003c/span\u003e {\n        \u003cspan class=\"hljs-type\"\u003eVStack\u003c/span\u003e {\n            \u003cspan class=\"hljs-type\"\u003eText\u003c/span\u003e(viewModel.message)\n            \u003cspan class=\"hljs-type\"\u003eButton\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"Send Notification\"\u003c/span\u003e) {\n                \u003cspan class=\"hljs-type\"\u003eNotificationCenter\u003c/span\u003e.default.post(name: \u003cspan class=\"hljs-type\"\u003eNotification\u003c/span\u003e.\u003cspan class=\"hljs-type\"\u003eName\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"MyNotification\"\u003c/span\u003e), object: \u003cspan class=\"hljs-literal\"\u003enil\u003c/span\u003e)\n            }\n        }\n        .padding()\n    }\n}\n\u003c/code\u003e\u003c/div\u003e\u003c/div\u003e\u003c/pre\u003e\u003cp\u003eএই উদাহরণে, Combine নোটিফিকেশন শোনে, ViewModel এর \u003ccode\u003emessage\u003c/code\u003e প্রপার্টি আপডেট করে এবং SwiftUI ভিউ সেই অনুযায়ী আপডেট হয়।\u003c/p\u003e\u003chr /\u003e\u003ch2\u003eউপসংহার\u003c/h2\u003e\u003cp\u003eCombine ফ্রেমওয়ার্ক হল অ্যাসিঙ্ক্রোনাস প্রোগ্রামিং এবং ইভেন্ট-ড্রাইভেন কোড ম্যানেজমেন্টের জন্য একটি শক্তিশালী টুল। \u003cstrong\u003ePublishers\u003c/strong\u003e, \u003cstrong\u003eSubscribers\u003c/strong\u003e, এবং \u003cstrong\u003eOperators\u003c/strong\u003e ব্যবহার করে, আপনি ডেটা স্ট্রিম গুলোকে ডিক্লারেটিভ উপায়ে হ্যান্ডল করতে পারেন, যা কোড রিডেবল এবং মেইনটেইন করা সহজ করে তোলে।\u003c/p\u003e\u003cp\u003eSwiftUI এর সাথে ডিপ ইন্টিগ্রেশনের মাধ্যমে Combine আরও শক্তিশালী হয়ে ওঠে, যা ডেটা মডেল এবং ইউজার ইন্টারফেসের মধ্যে রিয়েল-টাইম ডেটা বাইন্ডিং করতে সক্ষম করে।\u003c/p\u003e\u003cp\u003eনেটওয়ার্ক রিকোয়েস্ট হ্যান্ডলিং, টাইমার বা নোটিফিকেশন পর্যবেক্ষণ—Combine অ্যাসিঙ্ক্রোনাস টাস্ক হ্যান্ডল করার একটি পরিষ্কার এবং আধুনিক উপায় প্রদান করে। Apple ইকোসিস্টেমে Reactive Programming এর জন্য এটি একটি বড় পদক্ষেপ। শুভ কোডিং!\u003c/p\u003e",
      "author": {
        "id": "02262209569130030528",
        "displayName": "Rezaul Islam Tarek",
        "url": "https://www.blogger.com/profile/02262209569130030528",
        "image": {
          "url": "//2.bp.blogspot.com/-eGY33NWnnnw/ZywviOezqhI/AAAAAAAAV8M/KyO4eauDHZ8NTS9beS0SB_i2xwco4Uf4ACK4BGAYYCw/s35/Photoroom-20240512_215644.png"
        }
      },
      "replies": {
        "totalItems": "0",
        "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/1193431587290315384/comments"
      },
      "labels": [
        "combine",
        "iOS",
        "Swift"
      ],
      "etag": "\"dGltZXN0YW1wOiAxNzI5NjA5NzgyNzA1Cm9mZnNldDogLTI1MjAwMDAwCg\""
    },
    {
      "kind": "blogger#post",
      "id": "1769251889795813021",
      "blog": {
        "id": "6839959377168934742"
      },
      "published": "2024-09-13T00:10:00-07:00",
      "updated": "2024-09-13T00:10:23-07:00",
      "url": "http://techinterviewpro.blogspot.com/2024/09/queue-cell-reuse.html",
      "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/1769251889795813021",
      "title": "Queue এবং Cell Reuse কিভাবে কাজ করে",
      "content": "\u003cp\u003e&nbsp;ধরা যাক, আপনার \u003cstrong\u003eUITableView\u003c/strong\u003e-তে স্ক্রিনে সর্বোচ্চ ১০টি সেল একসাথে দেখা যাচ্ছে। এখন, আপনি যখন টেবিল ভিউতে স্ক্রল করবেন, তখন ১ম সেল স্ক্রিনের বাইরে চলে যাবে এবং ১১তম সেল স্ক্রিনে প্রবেশ করবে। এই প্রক্রিয়ায় \u003cstrong\u003eQueue\u003c/strong\u003e এবং \u003cstrong\u003eCell Reuse\u003c/strong\u003e কিভাবে কাজ করে তা বুঝতে হলে নিচের ধাপগুলো দেখতে হবে।\u003c/p\u003e\u003ch3\u003eQueue এর কাজ:\u003c/h3\u003e\u003cul\u003e\u003cli\u003eযখন আপনি \u003cstrong\u003eUITableView\u003c/strong\u003e স্ক্রল করেন, তখন স্ক্রিন থেকে বাইরে চলে যাওয়া সেলগুলোকে নতুনভাবে তৈরি না করে, সেগুলো \u003cstrong\u003eQueue\u003c/strong\u003e-তে রাখা হয়। Queue একটি স্টোরেজ হিসাবে কাজ করে, যেখানে পুরনো সেলগুলো জমা থাকে যাতে পুনরায় ব্যবহার করা যায়।\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003eউদাহরণ:\u003c/h3\u003e\u003col\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eপ্রথমবার সেল লোড\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli\u003eযখন টেবিল ভিউ প্রথম লোড হয়, তখন ১ থেকে ১০ নম্বর সেল স্ক্রিনে দৃশ্যমান হয়। এই ১০টি সেল প্রথমবার তৈরি হয় এবং তাদের ডেটা লোড করা হয়।\u003c/li\u003e\u003cli\u003eএই সময়ে Queue-এর মধ্যে কোনো সেল নেই, কারণ প্রতিটি সেল নতুনভাবে তৈরি হয়েছে।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eস্ক্রল করার সময় (১ম সেল স্ক্রিন থেকে বের হয়ে ১১তম সেল প্রবেশ করছে)\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli\u003eআপনি যখন স্ক্রল করে ১১তম সেল দেখবেন, তখন ১ম সেল স্ক্রিন থেকে বাইরে চলে যায় এবং সেই সেল Queue-তে জমা হয়।\u003c/li\u003e\u003cli\u003e\u003cstrong\u003edequeueReusableCell(withIdentifier:)\u003c/strong\u003e মেথড ব্যবহার করে Queue থেকে এই সেলটি বের করে নিয়ে আসা হয় এবং ১১তম সেলের জন্য নতুন ডেটা লোড করা হয়। Queue-এর কাজ হলো পুরনো সেলগুলোকে জমা রাখা এবং পুনরায় ব্যবহার করা।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch3\u003eকিভাবে Queue কাজ করে:\u003c/h3\u003e\u003col\u003e\u003cli\u003e\u003cstrong\u003eস্ক্রল শুরু\u003c/strong\u003e:\u003cul\u003e\u003cli\u003eপ্রথমে, আপনি স্ক্রল করে ১ম সেল স্ক্রিন থেকে বের করেন। এই সেলটি Queue-তে জমা হয়।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cstrong\u003e১১তম সেল লোড\u003c/strong\u003e:\u003cul\u003e\u003cli\u003eযখন ১১তম সেল স্ক্রিনে প্রবেশ করে, তখন Queue থেকে পুরনো ১ম সেলকে বের করা হয়, এবং নতুন ডেটা (১১তম ডেটা) সেই সেলে আপডেট করা হয়।\u003c/li\u003e\u003cli\u003eনতুন কোনো সেল তৈরি করা হয় না, বরং পুরনো সেলকে পুনরায় ব্যবহার করা হয়। Queue-এর মুল কাজ হলো পুনরায় ব্যবহারের জন্য সেল সংরক্ষণ করা।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch3\u003eQueue এর আকার:\u003c/h3\u003e\u003cul\u003e\u003cli\u003eQueue-এর আকার নির্ভর করে আপনি কতগুলো সেল স্ক্রিন থেকে বাইরে স্ক্রল করেছেন। প্রতিবার যখন একটি সেল স্ক্রিন থেকে বের হয়ে যায়, সেটি Queue-তে জমা হয়।\u003c/li\u003e\u003cli\u003eQueue-এর মধ্যে একবারে কতগুলো সেল থাকবে, তা নির্ভর করে আপনি স্ক্রল করে কতগুলো সেল স্ক্রিন থেকে বাইরে নিয়েছেন। তবে, Queue-এর সাইজ খুব বড় হয় না কারণ পুরনো সেলগুলোকে নতুনভাবে ব্যবহার করা হয়।\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003eসিস্টেম কিভাবে কাজ করে:\u003c/h3\u003e\u003col\u003e\u003cli\u003eআপনি যখন ১ম সেল স্ক্রল করে বাইরে নিয়ে যান, তখন সেটি Queue-তে জমা হয়।\u003c/li\u003e\u003cli\u003eএকই সময়ে ১১তম সেল স্ক্রিনে আসে। এই সেলটি নতুনভাবে তৈরি না করে, Queue থেকে ১ম সেলকে বের করে নতুন ডেটা লোড করা হয়।\u003c/li\u003e\u003cli\u003e২য় সেল যখন স্ক্রিন থেকে বাইরে যায়, সেটি Queue-তে জমা হয় এবং ১২তম সেল দেখানোর সময় সেই সেল পুনরায় ব্যবহার করা হয়।\u003c/li\u003e\u003c/ol\u003e\u003ch3\u003eউদাহরণ কোড:\u003c/h3\u003e\u003cpre class=\"!overflow-visible\"\u003e\u003cdiv class=\"dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative\"\u003e\u003cdiv class=\"flex items-center text-token-text-secondary bg-token-main-surface-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9\"\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv class=\"overflow-y-auto p-4\" dir=\"ltr\"\u003e\u003ccode class=\"!whitespace-pre hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etableView\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003etableView\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eUITableView\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003ecellForRowAt\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eindexPath\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eIndexPath\u003c/span\u003e) -&gt; \u003cspan class=\"hljs-type\"\u003eUITableViewCell\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// Queue থেকে সেল পুনরায় আনা হচ্ছে\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e cell \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e tableView.dequeueReusableCell(withIdentifier: \u003cspan class=\"hljs-string\"\u003e\"MyCell\"\u003c/span\u003e, for: indexPath)\n    \n    \u003cspan class=\"hljs-comment\"\u003e// সেলের নতুন ডেটা সেট করা হচ্ছে\u003c/span\u003e\n    cell.textLabel\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e.text \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Row \u003cspan class=\"hljs-subst\"\u003e\\(indexPath.row)\u003c/span\u003e\"\u003c/span\u003e\n    \n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e cell\n}\n\u003c/code\u003e\u003c/div\u003e\u003c/div\u003e\u003c/pre\u003e\u003ch3\u003eসংক্ষেপে:\u003c/h3\u003e\u003cul\u003e\u003cli\u003eআপনার স্ক্রিনে ১০টি সেল দৃশ্যমান হলে, ১ম সেল স্ক্রিন থেকে বের হওয়ার সময় সেটি Queue-তে জমা হয়।\u003c/li\u003e\u003cli\u003eQueue থেকে সেল বের করে নতুন সেল তৈরি না করে ১১তম সেল পুনরায় ব্যবহৃত হয়।\u003c/li\u003e\u003cli\u003eQueue-এর সাইজ স্ক্রল করার সময় কতগুলো সেল স্ক্রিন থেকে বাইরে গেছে তার উপর নির্ভর করে, তবে এই প্রক্রিয়ায় পুরনো সেলগুলো পুনরায় ব্যবহারের মাধ্যমে মেমোরি অপটিমাইজ হয়।\u003c/li\u003e\u003c/ul\u003e",
      "author": {
        "id": "02262209569130030528",
        "displayName": "Rezaul Islam Tarek",
        "url": "https://www.blogger.com/profile/02262209569130030528",
        "image": {
          "url": "//2.bp.blogspot.com/-eGY33NWnnnw/ZywviOezqhI/AAAAAAAAV8M/KyO4eauDHZ8NTS9beS0SB_i2xwco4Uf4ACK4BGAYYCw/s35/Photoroom-20240512_215644.png"
        }
      },
      "replies": {
        "totalItems": "0",
        "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/1769251889795813021/comments"
      },
      "labels": [
        "iOS",
        "Swift",
        "UIKit",
        "UITableView"
      ],
      "etag": "\"dGltZXN0YW1wOiAxNzI2MjExNDIzMDk0Cm9mZnNldDogLTI1MjAwMDAwCg\""
    },
    {
      "kind": "blogger#post",
      "id": "4436175952387382437",
      "blog": {
        "id": "6839959377168934742"
      },
      "published": "2024-09-13T00:07:00-07:00",
      "updated": "2024-09-13T00:07:16-07:00",
      "url": "http://techinterviewpro.blogspot.com/2024/09/uitableview.html",
      "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/4436175952387382437",
      "title": "কীভাবে UITableView সেল লোড এবং রিইউজ করে",
      "content": "\u003cp\u003e&nbsp;ধরুন, আপনার কাছে ১০০০টি ডেটা আছে এবং আপনি এগুলো \u003cstrong\u003eUITableView\u003c/strong\u003e-তে প্রদর্শন করতে চান। এখানে \u003cstrong\u003eUITableView\u003c/strong\u003e-এর একটি গুরুত্বপূর্ণ বৈশিষ্ট্য হলো এটি \u003cstrong\u003eসেল রিইউজ\u003c/strong\u003e (Cell Reuse) এর মাধ্যমে মেমোরি ব্যবহারের অপ্টিমাইজেশন করে। আসুন ধাপে ধাপে দেখে নেই কীভাবে এটি কাজ করে:\u003c/p\u003e\u003ch3\u003eকীভাবে UITableView সেল লোড এবং রিইউজ করে:\u003c/h3\u003e\u003col\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eদৃশ্যমান সেল তৈরি করা\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli\u003eযখন আপনি \u003cstrong\u003eUITableView\u003c/strong\u003e লোড করেন, তখন শুধু স্ক্রিনে দৃশ্যমান (Visible) সেলগুলোই তৈরি হয়।\u003c/li\u003e\u003cli\u003eযদি আপনার স্ক্রিনে ১০টি সেল দৃশ্যমান হয়, তবে শুধুমাত্র সেই ১০টি সেলই তৈরি হয়, ১০০০টি সেলের জন্য নতুন নতুন মেমোরি বরাদ্দ করা হয় না।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eসেল রিইউজ করা\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli\u003eআপনি যখন স্ক্রল করেন, তখন উপরের দিকের সেলগুলো স্ক্রিনের বাইরে চলে যায় এবং নতুন সেলগুলো স্ক্রিনে আসে।\u003c/li\u003e\u003cli\u003eস্ক্রিনের বাইরে চলে যাওয়া সেলগুলোকে মেমোরিতে রেখে দেওয়ার পরিবর্তে, সেগুলোকে একটি \u003cstrong\u003eQueue\u003c/strong\u003e-তে রাখা হয়। এই Queue-তে থাকা সেলগুলোকে \u003cstrong\u003ereusable cell\u003c/strong\u003e বলা হয়।\u003c/li\u003e\u003cli\u003eস্ক্রল করার সময় নতুন সেল তৈরি করার বদলে, Queue-তে থাকা সেলগুলো পুনরায় ব্যবহার (Reuse) করা হয়।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003edequeueReusableCell(withIdentifier:for:)\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli\u003eএই মেথডটি প্রতিটি সেল লোড করার সময় কল হয়। এটি Queue-তে থাকা সেলগুলোর মধ্যে থেকে একটি সেল পুনরায় ব্যবহার করে এবং সেই সেলে নতুন ডেটা আপডেট করে।\u003c/li\u003e\u003cli\u003eনতুন সেল তৈরি করার প্রয়োজন হয় না, যার ফলে মেমোরি সাশ্রয় হয়।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eprepareForReuse()\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli\u003eএকটি সেল যখন পুনরায় ব্যবহার করা হয়, তখন পূর্বে ব্যবহৃত ডেটা থেকে অবাঞ্ছিত কনটেন্ট দেখা যেতে পারে।\u003c/li\u003e\u003cli\u003eএজন্য \u003cstrong\u003eprepareForReuse()\u003c/strong\u003e মেথড ব্যবহার করা হয়। এটি সেলের পূর্বের ডেটা রিসেট করে, যাতে নতুন ডেটা সঠিকভাবে দেখানো যায়।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch3\u003eউদাহরণ:\u003c/h3\u003e\u003cp\u003eধরা যাক, আপনি ১০০০টি ডেটা টেবিল ভিউতে দেখাতে চান এবং প্রতিটি সেলে সেই ডেটাগুলো প্রদর্শন করবেন:\u003c/p\u003e\u003cpre class=\"!overflow-visible\"\u003e\u003cdiv class=\"dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative\"\u003e\u003cdiv class=\"flex items-center text-token-text-secondary bg-token-main-surface-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9\"\u003e\n\u003c/div\u003e\u003cdiv class=\"overflow-y-auto p-4\" dir=\"ltr\"\u003e\u003ccode class=\"!whitespace-pre hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etableView\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003etableView\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eUITableView\u003c/span\u003e, \u003cspan class=\"hljs-params\"\u003ecellForRowAt\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eindexPath\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eIndexPath\u003c/span\u003e) -&gt; \u003cspan class=\"hljs-type\"\u003eUITableViewCell\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// Reuse queue থেকে সেলটি নিয়ে আসে\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e cell \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e tableView.dequeueReusableCell(withIdentifier: \u003cspan class=\"hljs-string\"\u003e\"MyCell\"\u003c/span\u003e, for: indexPath) \u003cspan class=\"hljs-keyword\"\u003eas!\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eMyTableViewCell\u003c/span\u003e\n    \n    \u003cspan class=\"hljs-comment\"\u003e// সেলের কনটেন্ট আপডেট করে\u003c/span\u003e\n    cell.textLabel\u003cspan class=\"hljs-operator\"\u003e?\u003c/span\u003e.text \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\"Row \u003cspan class=\"hljs-subst\"\u003e\\(indexPath.row)\u003c/span\u003e\"\u003c/span\u003e\n    \n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e cell\n}\n\u003c/code\u003e\u003c/div\u003e\u003c/div\u003e\u003c/pre\u003e\u003ch3\u003eকীভাবে এটি কাজ করে:\u003c/h3\u003e\u003col\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eপ্রথম লোডিং\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli\u003eযখন টেবিল ভিউ প্রথম লোড হয়, তখন স্ক্রিনে যতগুলো সেল দৃশ্যমান হয় (ধরা যাক, ১০টি), সেই ১০টি সেল তৈরি হয়।\u003c/li\u003e\u003cli\u003e\u003ccode\u003ecellForRowAt\u003c/code\u003e মেথডটি কল হয় এবং Queue-তে কোনো সেল না থাকলে নতুন সেল তৈরি হয়।\u003c/li\u003e\u003cli\u003eপ্রথম ১০টি ডেটা সেলে আপডেট হয় এবং স্ক্রিনে প্রদর্শিত হয়।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eস্ক্রল করার সময়\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli\u003eআপনি যখন স্ক্রল করবেন, তখন উপরের সেলগুলো স্ক্রিনের বাইরে চলে যাবে এবং Queue-তে জমা হবে।\u003c/li\u003e\u003cli\u003eযখন আপনি নতুন সেল দেখতে পাবেন, তখন Queue থেকে পুরনো সেলটি নিয়ে এসে পুনরায় ব্যবহার করা হবে এবং সেই সেলে নতুন ডেটা আপডেট করা হবে।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eমেমোরি অপটিমাইজেশন\u003c/strong\u003e:\u003c/p\u003e\u003cul\u003e\u003cli\u003eসেল পুনরায় তৈরি না করে শুধুমাত্র Queue-তে জমা থাকা সেলগুলো পুনরায় ব্যবহার করা হয়। এর ফলে ১০০০টি সেল থাকা সত্ত্বেও শুধুমাত্র স্ক্রিনে দৃশ্যমান সেলগুলোর জন্যই মেমোরি বরাদ্দ করা হয়।\u003c/li\u003e\u003cli\u003eএটি মেমোরি সাশ্রয় করে এবং অ্যাপটি দ্রুত ও মসৃণভাবে কাজ করে।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch3\u003eউপকারিতা:\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eমেমোরি ব্যবহার কমানো\u003c/strong\u003e: ১০০০টি সেল তৈরি না করে শুধুমাত্র দৃশ্যমান সেলগুলো তৈরি হয় এবং স্ক্রল করার সময় পুরনো সেলগুলো পুনরায় ব্যবহার করা হয়।\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eদ্রুত পারফরম্যান্স\u003c/strong\u003e: নতুন সেল তৈরি করার প্রয়োজন না থাকায় স্ক্রলিং দ্রুত হয় এবং অ্যাপ ল্যাগ করে না।\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eprepareForReuse()\u003c/strong\u003e: এটি নিশ্চিত করে যে পুনরায় ব্যবহৃত সেলে পুরনো ডেটা দেখা যাবে না।\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eএভাবেই \u003cstrong\u003eUITableView\u003c/strong\u003e মেমোরি অপটিমাইজ করে এবং অ্যাপের পারফরম্যান্স উন্নত রাখে।\u003c/p\u003e",
      "author": {
        "id": "02262209569130030528",
        "displayName": "Rezaul Islam Tarek",
        "url": "https://www.blogger.com/profile/02262209569130030528",
        "image": {
          "url": "//2.bp.blogspot.com/-eGY33NWnnnw/ZywviOezqhI/AAAAAAAAV8M/KyO4eauDHZ8NTS9beS0SB_i2xwco4Uf4ACK4BGAYYCw/s35/Photoroom-20240512_215644.png"
        }
      },
      "replies": {
        "totalItems": "0",
        "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/4436175952387382437/comments"
      },
      "labels": [
        "iOS",
        "Swift",
        "UIKit",
        "UITableView"
      ],
      "etag": "\"dGltZXN0YW1wOiAxNzI2MjExMjM2Nzc4Cm9mZnNldDogLTI1MjAwMDAwCg\""
    },
    {
      "kind": "blogger#post",
      "id": "6176533635409718898",
      "blog": {
        "id": "6839959377168934742"
      },
      "published": "2024-09-12T08:31:00-07:00",
      "updated": "2024-09-12T08:31:38-07:00",
      "url": "http://techinterviewpro.blogspot.com/2024/09/the-different-states-of-uiviewcontroller.html",
      "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/6176533635409718898",
      "title": "The different states of UIViewController",
      "content": "\u003cp\u003e&nbsp;ধরুন, আপনি একটি iOS অ্যাপ তৈরি করছেন, যেখানে একটি স্ক্রিন আছে যা ব্যবহারকারীর প্রোফাইল দেখায়। এখন, আমরা ধরে নেবো এটি হলো \u003cstrong\u003eProfileViewController\u003c/strong\u003e, এবং আমরা এই স্ক্রিনে যাওয়ার এবং ফিরে আসার সময় UIViewController-এর বিভিন্ন স্টেটগুলো কিভাবে কাজ করে তা ব্যাখ্যা করব।\u003c/p\u003e\u003ch3\u003e1. \u003cstrong\u003eNot Yet Loaded (এখনো লোড হয়নি):\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eযখন অ্যাপটি প্রথমবার চালু হয়, \u003cstrong\u003eProfileViewController\u003c/strong\u003e-এর view এখনও মেমরিতে লোড হয়নি। আপনি হয়তো মেনু থেকে প্রোফাইল পেজে যাওয়ার আগে এই অবস্থায় থাকবেন। এই সময়ে, \u003cstrong\u003eProfileViewController\u003c/strong\u003e-এর view তৈরি হয়নি, তাই view সম্পর্কিত কোনো UI এ উপাদান মেমরিতে নেই।\u003c/p\u003e\u003ch3\u003e2. \u003cstrong\u003eLoaded (লোড হয়েছে):\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eযখন আপনি প্রোফাইল পেজটি দেখতে যাবেন, তখন \u003cstrong\u003eProfileViewController\u003c/strong\u003e-এর view মেমরিতে লোড হবে এবং \u003ccode\u003eviewDidLoad()\u003c/code\u003e মেথড কল হবে। এই অবস্থায় আপনি ইন্টারফেসের বিভিন্ন এলিমেন্ট যেমন প্রোফাইলের ছবি, নাম, ইমেইল প্রভৃতি সেটআপ করবেন। তবে, এটি এখনো ব্যবহারকারীর সামনে স্ক্রিনে দেখা যাচ্ছে না, শুধুমাত্র মেমরিতে লোড হয়েছে।\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eউদাহরণ:\u003c/strong\u003e\u003c/p\u003e\u003cpre class=\"!overflow-visible\"\u003e\u003cdiv class=\"dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative\"\u003e\u003cdiv class=\"sticky top-9 md:top-[5.75rem]\"\u003e\u003cdiv class=\"absolute bottom-0 right-2 flex h-9 items-center\"\u003e\u003cdiv class=\"flex items-center rounded bg-token-main-surface-secondary px-2 font-sans text-xs text-token-text-secondary\"\u003e\u003cbr /\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\"overflow-y-auto p-4\" dir=\"ltr\"\u003e\u003ccode class=\"!whitespace-pre hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eoverride\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eviewDidLoad\u003c/span\u003e() {\n    \u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.viewDidLoad()\n    \u003cspan class=\"hljs-comment\"\u003e// এখানে প্রোফাইলের ছবি, নাম ইত্যাদি লোড করা হবে\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/div\u003e\u003c/div\u003e\u003c/pre\u003e\u003ch3\u003e3. \u003cstrong\u003eAppearing (দেখা যাচ্ছে):\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eযখন \u003cstrong\u003eProfileViewController\u003c/strong\u003e স্ক্রিনে প্রদর্শিত হতে শুরু করবে, তখন \u003ccode\u003eviewWillAppear()\u003c/code\u003e মেথড কল হবে। এই সময়ে UI-তে এমন কিছু কাজ করতে পারেন, যা স্ক্রিনে প্রদর্শিত হওয়ার আগে করা উচিত, যেমন ডেটা রিফ্রেশ করা।\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eউদাহরণ:\u003c/strong\u003e\u003c/p\u003e\u003cpre class=\"!overflow-visible\"\u003e\u003cdiv class=\"dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative\"\u003e\u003cdiv class=\"sticky top-9 md:top-[5.75rem]\"\u003e\u003cdiv class=\"absolute bottom-0 right-2 flex h-9 items-center\"\u003e\u003cdiv class=\"flex items-center rounded bg-token-main-surface-secondary px-2 font-sans text-xs text-token-text-secondary\"\u003e\u003cbr /\u003e\u003c/div\u003e\u003c/div\u003e\u003c/div\u003e\u003cdiv class=\"overflow-y-auto p-4\" dir=\"ltr\"\u003e\u003ccode class=\"!whitespace-pre hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eoverride\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eviewWillAppear\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eanimated\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eBool\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.viewWillAppear(animated)\n    \u003cspan class=\"hljs-comment\"\u003e// প্রোফাইলের তথ্য আপডেট করে নেয়া, যাতে সবকিছু ঠিক থাকে\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/div\u003e\u003c/div\u003e\u003c/pre\u003e\u003ch3\u003e4. \u003cstrong\u003eVisible (সম্পূর্ণ দৃশ্যমান):\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eযখন \u003cstrong\u003eProfileViewController\u003c/strong\u003e সম্পূর্ণরূপে স্ক্রিনে দৃশ্যমান হয় এবং সবকিছু প্রস্তুত থাকে, তখন \u003ccode\u003eviewDidAppear()\u003c/code\u003e মেথড কল হবে। এই সময়ে আপনি animation বা network call শুরু করতে পারেন, যেগুলো UI সম্পূর্ণরূপে প্রস্তুত হওয়ার পরে করা উচিত।\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eউদাহরণ:\u003c/strong\u003e\u003c/p\u003e\u003cpre class=\"!overflow-visible\"\u003e\u003cdiv class=\"dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative\"\u003e\u003cdiv class=\"flex items-center text-token-text-secondary bg-token-main-surface-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9\"\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv class=\"overflow-y-auto p-4\" dir=\"ltr\"\u003e\u003ccode class=\"!whitespace-pre hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003eoverride\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eviewDidAppear\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eanimated\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eBool\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.viewDidAppear(animated)\n    \u003cspan class=\"hljs-comment\"\u003e// প্রোফাইলের জন্য অ্যানিমেশন চালানো বা background কাজ শুরু করা\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/div\u003e\u003c/div\u003e\u003c/pre\u003e\u003ch3\u003e5. \u003cstrong\u003eDisappearing (অদৃশ্য হচ্ছে):\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eযখন আপনি প্রোফাইল স্ক্রিন থেকে অন্য কোথাও চলে যাবেন, যেমন হোম পেজে ফিরে যাবেন, তখন \u003cstrong\u003eProfileViewController\u003c/strong\u003e স্ক্রিন থেকে সরতে শুরু করবে এবং \u003ccode\u003eviewWillDisappear()\u003c/code\u003e মেথড কল হবে। এই সময়ে আপনি এমন কাজ করতে পারেন যা স্ক্রিন বন্ধ হওয়ার আগে করতে হবে, যেমন কোনো ongoing কাজ বন্ধ করা।\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eউদাহরণ:\u003c/strong\u003e\u003c/p\u003e\u003cpre class=\"!overflow-visible\"\u003e\u003cdiv class=\"dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative\"\u003e\u003cdiv class=\"flex items-center text-token-text-secondary bg-token-main-surface-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9\"\u003e\u003cspan class=\"hljs-keyword\"\u003eoverride\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunc\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eviewWillDisappear\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003e_\u003c/span\u003e \u003cspan class=\"hljs-params\"\u003eanimated\u003c/span\u003e: \u003cspan class=\"hljs-type\"\u003eBool\u003c/span\u003e) {\u003c/div\u003e\u003cdiv class=\"overflow-y-auto p-4\" dir=\"ltr\"\u003e\u003ccode class=\"!whitespace-pre hljs language-swift\"\u003e    \u003cspan class=\"hljs-keyword\"\u003esuper\u003c/span\u003e.viewWillDisappear(animated)\n    \u003cspan class=\"hljs-comment\"\u003e// যদি কোনো API কল বা ডাটা লোড হচ্ছিল, তা বন্ধ করা\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/div\u003e\u003c/div\u003e\u003c/pre\u003e\u003ch3\u003e6. \u003cstrong\u003eUnloaded (আনলোড হয়েছে):\u003c/strong\u003e\u003c/h3\u003e\u003cp\u003eযখন \u003cstrong\u003eProfileViewController\u003c/strong\u003e পুরোপুরি স্ক্রিন থেকে সরানো হয়েছে এবং তার view hierarchy মেমরি থেকে আনলোড করা হয়েছে, তখন \u003cstrong\u003edeinit()\u003c/strong\u003e মেথড কল হতে পারে। এটি সেই সময় যখন view controller সম্পূর্ণভাবে মেমরি থেকে সরানো হয় এবং তার view আর প্রয়োজন নেই।\u003c/p\u003e\u003cp\u003e\u003cstrong\u003eউদাহরণ:\u003c/strong\u003e\u003c/p\u003e\u003cpre class=\"!overflow-visible\"\u003e\u003cdiv class=\"dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative\"\u003e\u003cdiv class=\"flex items-center text-token-text-secondary bg-token-main-surface-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9\"\u003e\u003cbr /\u003e\u003c/div\u003e\u003cdiv class=\"overflow-y-auto p-4\" dir=\"ltr\"\u003e\u003ccode class=\"!whitespace-pre hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003edeinit\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// যখন view controller সম্পূর্ণরূপে সরানো হবে, কোনো resources রিলিজ করা\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/div\u003e\u003c/div\u003e\u003c/pre\u003e\u003ch3\u003eউদাহরণে পুরো প্রক্রিয়া:\u003c/h3\u003e\u003col\u003e\u003cli\u003eআপনি অ্যাপ খুলেছেন—\u003cstrong\u003eProfileViewController\u003c/strong\u003e এখনো লোড হয়নি।\u003c/li\u003e\u003cli\u003eআপনি প্রোফাইল পেজে ক্লিক করলেন—\u003cstrong\u003eProfileViewController\u003c/strong\u003e লোড হচ্ছে (\u003ccode\u003eviewDidLoad()\u003c/code\u003e), কিন্তু এখনও দেখা যায় না।\u003c/li\u003e\u003cli\u003eস্ক্রিনে দেখা যাচ্ছে—\u003cstrong\u003eProfileViewController\u003c/strong\u003e দেখা শুরু হলো (\u003ccode\u003eviewWillAppear()\u003c/code\u003e), এবং UI প্রস্তুতি নিচ্ছে।\u003c/li\u003e\u003cli\u003eপ্রোফাইল স্ক্রিন সম্পূর্ণরূপে দৃশ্যমান—এখন সবকিছু চলছে (\u003ccode\u003eviewDidAppear()\u003c/code\u003e), অ্যানিমেশন শুরু হলো।\u003c/li\u003e\u003cli\u003eআপনি প্রোফাইল থেকে বেরিয়ে গেলেন—স্ক্রিন থেকে সরতে শুরু করলো (\u003ccode\u003eviewWillDisappear()\u003c/code\u003e), background কাজ বন্ধ হচ্ছে।\u003c/li\u003e\u003cli\u003eপ্রোফাইল স্ক্রিন পুরোপুরি সরিয়ে নেওয়া হয়েছে এবং মেমরি থেকে আনলোড হয়েছে—\u003cstrong\u003eProfileViewController\u003c/strong\u003e ধ্বংস হচ্ছে (\u003ccode\u003edeinit()\u003c/code\u003e), এবং এর সাথে সম্পর্কিত resources মুক্ত করা হচ্ছে।\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eএভাবে UIViewController-এর বিভিন্ন স্টেটগুলি বাস্তব প্রোফাইল স্ক্রিনের উদাহরণ দিয়ে ব্যাখ্যা করা যায়।\u003c/p\u003e",
      "author": {
        "id": "02262209569130030528",
        "displayName": "Rezaul Islam Tarek",
        "url": "https://www.blogger.com/profile/02262209569130030528",
        "image": {
          "url": "//2.bp.blogspot.com/-eGY33NWnnnw/ZywviOezqhI/AAAAAAAAV8M/KyO4eauDHZ8NTS9beS0SB_i2xwco4Uf4ACK4BGAYYCw/s35/Photoroom-20240512_215644.png"
        }
      },
      "replies": {
        "totalItems": "0",
        "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/6176533635409718898/comments"
      },
      "labels": [
        "iOS",
        "Swift",
        "UIKit"
      ],
      "etag": "\"dGltZXN0YW1wOiAxNzI2MTU1MDk4NzcxCm9mZnNldDogLTI1MjAwMDAwCg\""
    },
    {
      "kind": "blogger#post",
      "id": "5637285585067431974",
      "blog": {
        "id": "6839959377168934742"
      },
      "published": "2024-09-11T09:59:00-07:00",
      "updated": "2024-09-11T09:59:50-07:00",
      "url": "http://techinterviewpro.blogspot.com/2024/09/autolayout-frame-bounds.html",
      "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/5637285585067431974",
      "title": "Autolayout-এর আগে Frame এবং Bounds",
      "content": "\u003cp\u003e\u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e \u003cstrong\u003eAutolayout\u003c/strong\u003e এর আগেও বেশ গুরুত্বপূর্ণ ছিল, কারণ Autolayout আসার আগে iOS ডেভেলপাররা ম্যানুয়ালি ভিউয়ের অবস্থান এবং আকার নির্ধারণ করতেন। Autolayout চালু হওয়ার আগে, UI তৈরির জন্য মূলত \u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e ব্যবহৃত হতো, এবং ডেভেলপাররা ভিউগুলোর অবস্থান এবং আকার ম্যানুয়ালি ক্যালকুলেট করে সেট করতেন।\u003c/p\u003e\u003ch3\u003eAutolayout-এর আগে Frame এবং Bounds-এর প্রয়োজনীয়তা:\u003c/h3\u003e\u003cp\u003eAutolayout না থাকায়, ডেভেলপারদের নিজে থেকেই ভিউগুলোর আকার এবং অবস্থান ক্যালকুলেট করতে হতো। স্ক্রিনের বিভিন্ন আকার বা ডিভাইসের রেজোলিউশন অনুযায়ী UI সামঞ্জস্য করতে ডেভেলপাররা বিভিন্ন প্রোগ্রাম্যাটিক কৌশল ব্যবহার করতেন। এই সময়ে \u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e ব্যবহার করে নিম্নলিখিত কাজগুলো সম্পন্ন করা হতো:\u003c/p\u003e\u003col\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eম্যানুয়ালি পজিশনিং:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eস্ক্রিনের বিভিন্ন পজিশনে ভিউ স্থাপন করার জন্য \u003cstrong\u003eFrame\u003c/strong\u003e ব্যবহার করা হতো। ভিউ কোথায় থাকবে এবং এর প্রস্থ ও উচ্চতা কী হবে, তা নির্ধারণ করা হতো।\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eউদাহরণ:\u003c/p\u003e\u003cpre class=\"!overflow-visible\"\u003e\u003cdiv class=\"dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative\"\u003e\u003cdiv class=\"overflow-y-auto p-4\" dir=\"ltr\"\u003e\u003ccode class=\"!whitespace-pre hljs language-swift\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e button \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eUIButton\u003c/span\u003e()\nbutton.frame \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eCGRect\u003c/span\u003e(x: \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e, y: \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, width: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e, height: \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e)\n\u003c/code\u003e\u003c/div\u003e\u003c/div\u003e\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eরেসপন্সিভ ডিজাইন (স্ক্রিন সাইজ সামঞ্জস্য):\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eবিভিন্ন স্ক্রিন সাইজে ভিউগুলো কেমন দেখাবে, তা নির্ধারণ করার জন্য প্রায়ই \u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e এর মান ম্যানুয়ালি পরিবর্তন করতে হতো। এটি করতে গিয়ে ডেভেলপাররা স্ক্রিনের রেজোলিউশন অনুযায়ী গণনা করতেন এবং ভিউগুলোর অবস্থান ক্যালকুলেট করতেন।\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eউদাহরণ:\u003c/p\u003e\u003cpre class=\"!overflow-visible\"\u003e\u003cdiv class=\"dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative\"\u003e\u003cdiv class=\"flex items-center text-token-text-secondary bg-token-main-surface-secondary px-4 py-2 text-xs font-sans justify-between rounded-t-md h-9\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e screenWidth \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eUIScreen\u003c/span\u003e.main.bounds.width\u003c/div\u003e\u003cdiv class=\"overflow-y-auto p-4\" dir=\"ltr\"\u003e\u003ccode class=\"!whitespace-pre hljs language-swift\"\u003ebutton.frame \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eCGRect\u003c/span\u003e(x: screenWidth \u003cspan class=\"hljs-operator\"\u003e/\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e \u003cspan class=\"hljs-operator\"\u003e-\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, y: \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, width: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e, height: \u003cspan class=\"hljs-number\"\u003e50\u003c/span\u003e)\n\u003c/code\u003e\u003c/div\u003e\u003c/div\u003e\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eঅ্যানিমেশন এবং ট্রান্সফর্ম:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e ব্যবহার করে ম্যানুয়ালি অ্যানিমেশন করা যেতো। উদাহরণস্বরূপ, ভিউটিকে মুভ করানো, রিসাইজ করা বা ঘোরানোর জন্য \u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e পরিবর্তন করা হতো।\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eউদাহরণ:\u003c/p\u003e\u003cpre class=\"!overflow-visible\"\u003e\u003cdiv class=\"dark bg-gray-950 contain-inline-size rounded-md border-[0.5px] border-token-border-medium relative\"\u003e\u003cdiv class=\"overflow-y-auto p-4\" dir=\"ltr\"\u003e\u003ccode class=\"!whitespace-pre hljs language-swift\"\u003e\u003cspan class=\"hljs-type\"\u003eUIView\u003c/span\u003e.animate(withDuration: \u003cspan class=\"hljs-number\"\u003e0.5\u003c/span\u003e) {\n    myView.frame \u003cspan class=\"hljs-operator\"\u003e=\u003c/span\u003e \u003cspan class=\"hljs-type\"\u003eCGRect\u003c/span\u003e(x: \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e, y: \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e, width: \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e, height: \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e)\n}\n\u003c/code\u003e\u003c/div\u003e\u003c/div\u003e\u003c/pre\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eপজিশনিং এবং লেআউট লজিক:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003eডেভেলপারদের নিজে থেকেই সব ভিউয়ের মধ্যে সমন্বয় করতে হতো। কোনো ভিউ একটি নির্দিষ্ট অবস্থানে থাকলে সেটির পাশের ভিউয়ের \u003cstrong\u003eFrame\u003c/strong\u003e ম্যানুয়ালি সেট করতে হতো, যাতে ভিউগুলো ঠিকঠাকভাবে সাজানো থাকে।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch3\u003eFrame এবং Bounds-এর সীমাবদ্ধতা Autolayout না থাকার সময়:\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eডিভাইসের আকার অনুযায়ী ম্যানুয়াল কাজ:\u003c/strong\u003e ডেভেলপারদের প্রত্যেক স্ক্রিন সাইজের জন্য আলাদা ক্যালকুলেশন করতে হতো। যেমন iPhone 4s এর জন্য আলাদা Frame সেট করতে হতো, আবার iPhone 6 এর জন্য ভিন্ন। এর ফলে কোড জটিল হয়ে উঠতো।\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eভিউগুলোর একে অপরের সাথে সম্পর্ক:\u003c/strong\u003e Frame ব্যবহার করে ভিউগুলোর অবস্থান নির্ধারণ করা কঠিন ছিল যদি একটি ভিউ সরাসরি অন্য ভিউয়ের সাথে সম্পর্কিত হতো। উদাহরণস্বরূপ, যদি একটি বাটন এবং লেবেল পাশাপাশি থাকে এবং আপনি চাইলে বাটনটি লেবেলের নিচে চলে আসবে, তবে আপনাকে এর জন্য ম্যানুয়ালি ক্যালকুলেশন করতে হতো।\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003eAutolayout আসার পর পরিবর্তন:\u003c/h3\u003e\u003cp\u003eAutolayout আসার পর, \u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e এর পরিবর্তে ডেভেলপাররা \u003cstrong\u003eConstraints\u003c/strong\u003e ব্যবহার করে ভিউগুলোর অবস্থান এবং আকার নির্ধারণ করেন। এর ফলে স্ক্রিনের বিভিন্ন আকারে UI তৈরি করা সহজ হয়। এখন Autolayout নিজেই বিভিন্ন ডিভাইসের জন্য সঠিক ক্যালকুলেশন করে, এবং ডেভেলপারদের ম্যানুয়ালি পজিশনিং এবং সাইজিং করার দরকার পড়ে না।\u003c/p\u003e\u003cp\u003eতবে, \u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e এখনও প্রাসঙ্গিক, কারণ Autolayout-এর পাশাপাশি কিছু ম্যানুয়াল ভিউ পজিশনিং বা অ্যানিমেশন করতে \u003cstrong\u003eFrame\u003c/strong\u003e প্রয়োজন হয়। বিশেষত অ্যানিমেশন, স্ক্রল ভিউ-এর কন্টেন্ট সাইজ বা কাস্টম লেআউট তৈরির জন্য \u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e এখনও ব্যবহৃত হয়।\u003c/p\u003e\u003chr /\u003e\u003cp\u003e\u003cstrong\u003eসারসংক্ষেপে\u003c/strong\u003e, Autolayout-এর আগের সময়ে \u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e অত্যন্ত গুরুত্বপূর্ণ ভূমিকা পালন করতো, কারণ তখন সবকিছু ম্যানুয়ালি পজিশন করতে হতো। তবে Autolayout আসার পর স্বয়ংক্রিয়ভাবে লেআউট ম্যানেজ করার ফলে ডেভেলপারদের জীবন অনেক সহজ হয়ে গেছে, এবং \u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e এখন নির্দিষ্ট কিছু কাজে ব্যবহৃত হয়।\u003c/p\u003e",
      "author": {
        "id": "02262209569130030528",
        "displayName": "Rezaul Islam Tarek",
        "url": "https://www.blogger.com/profile/02262209569130030528",
        "image": {
          "url": "//2.bp.blogspot.com/-eGY33NWnnnw/ZywviOezqhI/AAAAAAAAV8M/KyO4eauDHZ8NTS9beS0SB_i2xwco4Uf4ACK4BGAYYCw/s35/Photoroom-20240512_215644.png"
        }
      },
      "replies": {
        "totalItems": "0",
        "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/5637285585067431974/comments"
      },
      "labels": [
        "iOS",
        "Swift",
        "UIKit"
      ],
      "etag": "\"dGltZXN0YW1wOiAxNzI2MDczOTkwMDcxCm9mZnNldDogLTI1MjAwMDAwCg\""
    },
    {
      "kind": "blogger#post",
      "id": "595305050996956495",
      "blog": {
        "id": "6839959377168934742"
      },
      "published": "2024-09-11T09:34:00-07:00",
      "updated": "2024-09-11T09:34:21-07:00",
      "url": "http://techinterviewpro.blogspot.com/2024/09/frame-bounds.html",
      "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/595305050996956495",
      "title": "Frame এবং Bounds এর বিষয়ে আরও বিশদভাবে আলোচনা",
      "content": "\u003cp\u003e&nbsp;\u003c/p\u003e\u003ch3\u003eস্ক্রোল ভিউ-এর ক্ষেত্রে Frame এবং Bounds:\u003c/h3\u003e\u003cp\u003eস্ক্রোল ভিউতে কনটেন্ট সাধারণত বড় হয় এবং আপনি এটি স্ক্রোল করতে পারেন। স্ক্রোল ভিউয়ের মূল কাজ হলো এর মধ্যে বড় কনটেন্টকে ধারণ করা এবং স্ক্রোলিংয়ের মাধ্যমে তা প্রদর্শন করা। এই ক্ষেত্রে \u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e কীভাবে কাজ করে তা আরও ভালোভাবে বোঝা যাবে।\u003c/p\u003e\u003ch4\u003e১. \u003cstrong\u003eFrame\u003c/strong\u003e:\u003c/h4\u003e\u003cp\u003eস্ক্রোল ভিউ-এর \u003cstrong\u003eFrame\u003c/strong\u003e মানে এটি স্ক্রিনের কোথায় অবস্থান করছে, এবং তার আকার কী। উদাহরণস্বরূপ, যদি আপনার স্ক্রোল ভিউ-এর ফ্রেম হয় \u003ccode\u003e(50, 100, 300, 500)\u003c/code\u003e:\u003c/p\u003e\u003cul\u003e\u003cli\u003eএর অর্থ হলো স্ক্রোল ভিউয়ের বাম প্রান্ত স্ক্রিনের বাম দিক থেকে ৫০ পয়েন্ট দূরে এবং উপরের দিক থেকে ১০০ পয়েন্ট দূরে।\u003c/li\u003e\u003cli\u003eস্ক্রোল ভিউটির প্রস্থ ৩০০ পয়েন্ট এবং উচ্চতা ৫০০ পয়েন্ট। এই \u003cstrong\u003eFrame\u003c/strong\u003e ভিউটির স্ক্রিনে অবস্থান ও আকার নির্ধারণ করে এবং এটি সুপারভিউয়ের কো-অর্ডিনেট সিস্টেমে কাজ করে।\u003c/li\u003e\u003c/ul\u003e\u003ch4\u003e২. \u003cstrong\u003eBounds\u003c/strong\u003e:\u003c/h4\u003e\u003cp\u003eস্ক্রোল ভিউয়ের \u003cstrong\u003eBounds\u003c/strong\u003e মূলত ভিউয়ের মধ্যে কী দেখানো হচ্ছে তা নির্ধারণ করে। স্ক্রোলিং করার সময়, কনটেন্টের দৃশ্যমান অংশ \u003cstrong\u003eBounds\u003c/strong\u003e দ্বারা নির্ধারিত হয়। উদাহরণস্বরূপ, যদি স্ক্রোল ভিউয়ের বাউন্ডস হয় \u003ccode\u003e(0, 0, 300, 500)\u003c/code\u003e, এটি দেখায় যে স্ক্রোল ভিউয়ের দৃশ্যমান অংশটি তার প্রথম অংশ থেকেই শুরু হচ্ছে। এখন আপনি যদি স্ক্রোল করেন এবং বাউন্ডস হয় \u003ccode\u003e(0, 200, 300, 500)\u003c/code\u003e, এর মানে হলো, স্ক্রোল ভিউয়ের ২০০ পয়েন্ট নীচের কনটেন্ট থেকে দৃশ্যমান হচ্ছে।\u003c/p\u003e\u003ch3\u003eভিন্ন উদাহরণ:\u003c/h3\u003e\u003cp\u003eধরা যাক আপনার একটি ভিউ রয়েছে, যেখানে আপনি একটি ইমেজ প্রদর্শন করছেন। ভিউটির ফ্রেম এবং বাউন্ডস কীভাবে কাজ করে তা বোঝা যাক:\u003c/p\u003e\u003ch4\u003e১. \u003cstrong\u003eFrame\u003c/strong\u003e (উচ্চ এবং প্রস্থে পরিবর্তন):\u003c/h4\u003e\u003cp\u003eআপনি যদি ভিউটির ফ্রেম সেট করেন \u003ccode\u003e(20, 50, 150, 150)\u003c/code\u003e, তাহলে:\u003c/p\u003e\u003cul\u003e\u003cli\u003eভিউটি স্ক্রিনের বাম প্রান্ত থেকে ২০ পয়েন্ট দূরে এবং উপরের দিক থেকে ৫০ পয়েন্ট দূরে।\u003c/li\u003e\u003cli\u003eভিউটির প্রস্থ এবং উচ্চতা ১৫০ পয়েন্ট।\u003c/li\u003e\u003c/ul\u003e\u003cp\u003eএই ফ্রেম সেটিং দ্বারা ভিউটি তার সুপারভিউয়ের অবস্থান এবং আকার নির্ধারণ করে।\u003c/p\u003e\u003ch4\u003e২. \u003cstrong\u003eBounds\u003c/strong\u003e (অভ্যন্তরীণ স্কেলিং বা জুম):\u003c/h4\u003e\u003cp\u003eএখন, যদি আপনি ইমেজ ভিউয়ের বাউন্ডস পরিবর্তন করেন, যেমন \u003ccode\u003e(0, 0, 300, 300)\u003c/code\u003e এ সেট করেন, তাহলে ইমেজটি তার নিজস্ব কো-অর্ডিনেট সিস্টেমে ৩০০ পয়েন্ট প্রস্থ এবং উচ্চতা নিয়ে পুনঃস্কেল করা হবে। যদিও ফ্রেমটি একই থাকে, বাউন্ডস পরিবর্তনের মাধ্যমে কনটেন্ট বড় বা ছোট হতে পারে।\u003c/p\u003e\u003ch3\u003eক্লিপিং এবং ট্রান্সফর্ম-এর ক্ষেত্রে Frame এবং Bounds:\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e ক্লিপিং বা ট্রান্সফর্ম করার ক্ষেত্রেও গুরুত্বপূর্ণ। ভিউয়ের ট্রান্সফর্মিং করার সময়, ফ্রেমের পরিবর্তন ঘটে কারণ এটি সুপারভিউয়ের সাথে সম্পর্কিত। কিন্তু বাউন্ডস সাধারণত অভ্যন্তরীণ অবস্থান এবং মাত্রার ওপর ভিত্তি করে থাকে।\u003c/p\u003e\u003ch4\u003eউদাহরণ: রোটেশন\u003c/h4\u003e\u003cp\u003eআপনি যদি একটি ভিউকে ৪৫ ডিগ্রি ঘোরান, তাহলে এর ফ্রেম পরিবর্তিত হবে কারণ এটি সুপারভিউয়ের সাথে সম্পর্কিত। তবে, তার বাউন্ডস পরিবর্তিত হবে না, কারণ এটি তার নিজস্ব কো-অর্ডিনেট সিস্টেমের ওপর ভিত্তি করে থাকে।\u003c/p\u003e\u003ch3\u003eকিছু অতিরিক্ত বিষয়:\u003c/h3\u003e\u003col\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eCenter:\u003c/strong\u003e ভিউয়ের \u003cstrong\u003eFrame\u003c/strong\u003e এর সাথে জড়িত আরও একটি গুরুত্বপূর্ণ প্রোপার্টি হলো \u003cstrong\u003ecenter\u003c/strong\u003e। Center সেট করার মাধ্যমে আপনি ভিউটির কেন্দ্রবিন্দু নির্ধারণ করতে পারেন, যা ফ্রেমের \u003ccode\u003eorigin\u003c/code\u003e (x, y) এর উপর ভিত্তি করে পরিবর্তিত হয়।\u003c/p\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eAutoresizing এবং Autolayout-এর ক্ষেত্রে পার্থক্য:\u003c/strong\u003e আপনি যখন autolayout বা autoresizing ব্যবহার করেন, তখন ফ্রেমের পরিবর্তন ঘটে। অর্থাৎ, ভিউটির আকার বা অবস্থান পরিবর্তিত হলে ফ্রেমের আপডেট হয়, কিন্তু বাউন্ডস সাধারণত অভ্যন্তরীণ কনটেন্টের সাথে সম্পর্কিত থাকে এবং সরাসরি এর পরিবর্তন ঘটে না।\u003c/p\u003e\u003c/li\u003e\u003c/ol\u003e\u003ch3\u003eউপসংহার:\u003c/h3\u003e\u003cp\u003e\u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e হলো iOS-এর ভিউ সিস্টেমে অত্যন্ত গুরুত্বপূর্ণ প্রোপার্টি। Frame ভিউয়ের বাহ্যিক অবস্থান এবং আকার নির্ধারণ করে, যেখানে Bounds ভিউয়ের অভ্যন্তরীণ কনটেন্ট এবং তার প্রদর্শনের ক্ষেত্র নির্ধারণ করে। স্ক্রোলিং, জুমিং, ট্রান্সফর্ম, এবং অটো-লেআউটের ক্ষেত্রে এই প্রোপার্টিগুলির প্রভাব নির্ভর করে আপনি কীভাবে ভিউয়ের আচরণ পরিচালনা করতে চান তার উপর।\u003c/p\u003e\u003cp\u003eআশা করি, এই বিশদ ব্যাখ্যা আপনার বিষয়টি আরও পরিষ্কার করেছে!\u003c/p\u003e",
      "author": {
        "id": "02262209569130030528",
        "displayName": "Rezaul Islam Tarek",
        "url": "https://www.blogger.com/profile/02262209569130030528",
        "image": {
          "url": "//2.bp.blogspot.com/-eGY33NWnnnw/ZywviOezqhI/AAAAAAAAV8M/KyO4eauDHZ8NTS9beS0SB_i2xwco4Uf4ACK4BGAYYCw/s35/Photoroom-20240512_215644.png"
        }
      },
      "replies": {
        "totalItems": "0",
        "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/595305050996956495/comments"
      },
      "labels": [
        "iOS",
        "Swift",
        "UIKit"
      ],
      "etag": "\"dGltZXN0YW1wOiAxNzI2MDcyNDYxNDgxCm9mZnNldDogLTI1MjAwMDAwCg\""
    },
    {
      "kind": "blogger#post",
      "id": "5175409095964149759",
      "blog": {
        "id": "6839959377168934742"
      },
      "published": "2024-09-11T08:56:00-07:00",
      "updated": "2024-09-11T08:56:29-07:00",
      "url": "http://techinterviewpro.blogspot.com/2024/09/uikit-clipstobounds-maskstobounds.html",
      "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/5175409095964149759",
      "title": "UIKit-এ clipsToBounds এবং masksToBounds",
      "content": "\u003cp\u003e&nbsp;\u003cstrong\u003eUIKit\u003c/strong\u003e-এ \u003ccode\u003eclipsToBounds\u003c/code\u003e এবং \u003ccode\u003emasksToBounds\u003c/code\u003e এর কার্যকারিতা একই রকম মনে হলেও, এদের প্রয়োগ ভিউ হায়ারার্কির বিভিন্ন স্তরে হয়।\u003c/p\u003e\u003ch3\u003eমূল পার্থক্য:\u003c/h3\u003e\u003col\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eপ্রোপার্টির ধরন:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eclipsToBounds\u003c/code\u003e হলো \u003ccode\u003eUIView\u003c/code\u003e এর প্রোপার্টি, আর \u003ccode\u003emasksToBounds\u003c/code\u003e হলো \u003ccode\u003eCALayer\u003c/code\u003e এর প্রোপার্টি।\u003c/li\u003e\u003cli\u003e\u003ccode\u003eclipsToBounds\u003c/code\u003e যেকোনো ভিউতে ব্যবহার করা যায়, আর \u003ccode\u003emasksToBounds\u003c/code\u003e শুধুমাত্র লেয়ারে প্রযোজ্য।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eফলাফল:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eclipsToBounds\u003c/code\u003e ব্যবহার করলে, ভিউয়ের সীমার বাইরে থাকা কনটেন্ট কাট হয়ে যায়।\u003c/li\u003e\u003cli\u003e\u003ccode\u003emasksToBounds\u003c/code\u003e ব্যবহার করলে, লেয়ারের সীমার বাইরে থাকা কনটেন্ট মাস্কের মাধ্যমে অদৃশ্য হয়ে যায়।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eপারফরম্যান্স:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eclipsToBounds\u003c/code\u003e তুলনামূলকভাবে দ্রুত কাজ করে, কারণ এটি ভিউয়ের কনটেন্ট সরাসরি ক্লিপ করে।\u003c/li\u003e\u003cli\u003e\u003ccode\u003emasksToBounds\u003c/code\u003e মাস্ক তৈরি করে, যা বেশি রিসোর্স ব্যবহার করে এবং ধীরগতি হতে পারে।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003cli\u003e\u003cp\u003e\u003cstrong\u003eইনহেরিটেন্স:\u003c/strong\u003e\u003c/p\u003e\u003cul\u003e\u003cli\u003e\u003ccode\u003eclipsToBounds\u003c/code\u003e ব্যবহার করলে, প্যারেন্ট ভিউয়ের বাইরের সব সাবভিউও ক্লিপ হয়ে যাবে।\u003c/li\u003e\u003cli\u003e\u003ccode\u003emasksToBounds\u003c/code\u003e শুধু প্যারেন্ট লেয়ারে প্রভাব ফেলে, সাবলেয়ারগুলোর ওপর প্রভাব পড়ে না।\u003c/li\u003e\u003c/ul\u003e\u003c/li\u003e\u003c/ol\u003e\u003cp\u003eঅ্যাপল সুপারিশ করে যে যেখানে \u003ccode\u003eUIView\u003c/code\u003e এবং \u003ccode\u003eCALayer\u003c/code\u003e এর সমান কার্যকারিতা থাকে, সেখানে \u003ccode\u003eUIView\u003c/code\u003e এর প্রোপার্টি ব্যবহার করা উচিত।\u003c/p\u003e",
      "author": {
        "id": "02262209569130030528",
        "displayName": "Rezaul Islam Tarek",
        "url": "https://www.blogger.com/profile/02262209569130030528",
        "image": {
          "url": "//2.bp.blogspot.com/-eGY33NWnnnw/ZywviOezqhI/AAAAAAAAV8M/KyO4eauDHZ8NTS9beS0SB_i2xwco4Uf4ACK4BGAYYCw/s35/Photoroom-20240512_215644.png"
        }
      },
      "replies": {
        "totalItems": "0",
        "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/5175409095964149759/comments"
      },
      "labels": [
        "iOS",
        "Swift",
        "UIKit"
      ],
      "etag": "\"dGltZXN0YW1wOiAxNzI2MDcwMTg5OTIyCm9mZnNldDogLTI1MjAwMDAwCg\""
    },
    {
      "kind": "blogger#post",
      "id": "6870910995782633637",
      "blog": {
        "id": "6839959377168934742"
      },
      "published": "2024-09-11T08:52:00-07:00",
      "updated": "2024-09-11T08:52:50-07:00",
      "url": "http://techinterviewpro.blogspot.com/2024/09/frame-vs-bounds-ios.html",
      "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/6870910995782633637",
      "title": "Frame vs Bounds iOS",
      "content": "\u003cp\u003eএকটি ভিউ হলো এমন একটি অবজেক্ট যা স্ক্রিনে একটি আয়তাকার এলাকাকে উপস্থাপন করে এবং এটি কনটেন্ট ড্রইং ও ইউজার ইন্টারঅ্যাকশন পরিচালনার দায়িত্ব পালন করে। যখন ভিউয়ের উত্স এবং মাত্রার কথা বলা হয়, তখন \u003cstrong\u003eFrame\u003c/strong\u003e এবং \u003cstrong\u003eBounds\u003c/strong\u003e শব্দগুলো ব্যবহৃত হয়।\u003c/p\u003e\u003ch3\u003eFrame:\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eFrame\u003c/strong\u003e হলো ভিউয়ের অবস্থান ও মাত্রা (Origin এবং Dimension), যা এর সুপারভিউয়ের কো-অর্ডিনেট সিস্টেমের সাথে সম্পর্কিত।\u003c/li\u003e\u003cli\u003eএটি পয়েন্টে নির্ধারিত হয়, যা ডিভাইসের স্ক্রিন রেজোলিউশনের ওপর নির্ভর করে না।\u003c/li\u003e\u003cli\u003eউদাহরণস্বরূপ, যদি কোনো ভিউয়ের ফ্রেম হয় \u003ccode\u003e(10, 10, 100, 100)\u003c/code\u003e, তাহলে এর অর্থ হলো ভিউটির উপরের বাম কোণ তার সুপারভিউয়ের বাম প্রান্ত থেকে ১০ পয়েন্ট এবং উপরের প্রান্ত থেকে ১০ পয়েন্ট দূরে অবস্থিত। এবং ভিউটির প্রস্থ ও উচ্চতা উভয়ই ১০০ পয়েন্ট।\u003c/li\u003e\u003c/ul\u003e\u003ch3\u003eBounds:\u003c/h3\u003e\u003cul\u003e\u003cli\u003e\u003cstrong\u003eBounds\u003c/strong\u003e হলো ভিউয়ের অবস্থান ও মাত্রা, যা এর নিজস্ব কো-অর্ডিনেট সিস্টেমের সাথে সম্পর্কিত।\u003c/li\u003e\u003cli\u003eএটি পয়েন্টে নির্ধারিত হয়। ফ্রেমের মতো এটি সুপারভিউয়ের কো-অর্ডিনেট সিস্টেমকে বিবেচনায় নেয় না।\u003c/li\u003e\u003cli\u003e\u003cstrong\u003eBounds\u003c/strong\u003e এর উত্স (Origin) সবসময় \u003ccode\u003e(0, 0)\u003c/code\u003e হয়, যা ভিউয়ের উপরের বাম কোণ।\u003c/li\u003e\u003cli\u003eউদাহরণস্বরূপ, যদি কোনো ভিউয়ের \u003cstrong\u003eBounds\u003c/strong\u003e হয় \u003ccode\u003e(0, 0, 100, 100)\u003c/code\u003e, তাহলে এর অর্থ হলো ভিউটির উপরের বাম কোণ নিজস্ব কো-অর্ডিনেট সিস্টেমের উপরের বাম কোণ থেকে শুরু হয়েছে, এবং এর প্রস্থ ও উচ্চতা ১০০ পয়েন্ট।\u003c/li\u003e\u003c/ul\u003e\u003cp\u003e\u003cstrong\u003eসারসংক্ষেপে\u003c/strong\u003e, \u003cstrong\u003eFrame\u003c/strong\u003e সুপারভিউয়ের কো-অর্ডিনেট সিস্টেম অনুযায়ী ভিউয়ের অবস্থান ও মাত্রা নির্দেশ করে, আর \u003cstrong\u003eBounds\u003c/strong\u003e ভিউয়ের নিজস্ব কো-অর্ডিনেট সিস্টেম অনুযায়ী এর অবস্থান ও মাত্রা নির্ধারণ করে।\u003c/p\u003e",
      "author": {
        "id": "02262209569130030528",
        "displayName": "Rezaul Islam Tarek",
        "url": "https://www.blogger.com/profile/02262209569130030528",
        "image": {
          "url": "//2.bp.blogspot.com/-eGY33NWnnnw/ZywviOezqhI/AAAAAAAAV8M/KyO4eauDHZ8NTS9beS0SB_i2xwco4Uf4ACK4BGAYYCw/s35/Photoroom-20240512_215644.png"
        }
      },
      "replies": {
        "totalItems": "0",
        "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/6870910995782633637/comments"
      },
      "labels": [
        "iSO",
        "Swift",
        "UIKit"
      ],
      "etag": "\"dGltZXN0YW1wOiAxNzI2MDY5OTcwNDE5Cm9mZnNldDogLTI1MjAwMDAwCg\""
    },
    {
      "kind": "blogger#post",
      "id": "8281872301492455126",
      "blog": {
        "id": "6839959377168934742"
      },
      "published": "2023-03-13T19:00:00-07:00",
      "updated": "2023-03-13T19:00:50-07:00",
      "url": "http://techinterviewpro.blogspot.com/2023/03/what-is-difference-between-async-and.html",
      "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/8281872301492455126",
      "title": "What is the difference between async and launch in Kotlin Android coroutines?",
      "content": "\u003cp\u003e\u003cspan style=\"background-color: white;\"\u003e\u003cspan style=\"font-family: Poppins;\"\u003e&nbsp;\u003cspan style=\"color: #374151; font-size: 16px; white-space: pre-wrap;\"\u003eIn Kotlin Android coroutines, \u003c/span\u003e\u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600; white-space: pre-wrap;\"\u003easync\u003c/code\u003e\u003cspan style=\"color: #374151; font-size: 16px; white-space: pre-wrap;\"\u003e and \u003c/span\u003e\u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600; white-space: pre-wrap;\"\u003elaunch\u003c/code\u003e\u003cspan style=\"color: #374151; font-size: 16px; white-space: pre-wrap;\"\u003e are two ways to launch a new coroutine.\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\u003cul style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: #374151; display: flex; flex-direction: column; font-size: 16px; list-style-image: initial; list-style-position: initial; margin: 1.25em 0px; padding: 0px 0px 0px 1rem; white-space: pre-wrap;\"\u003e\u003cli style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; display: block; margin: 0px; padding-left: 0.375em; position: relative;\"\u003e\u003cp style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; margin: 0px;\"\u003e\u003cspan style=\"background-color: white;\"\u003e\u003cspan style=\"font-family: Poppins;\"\u003e\u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003elaunch\u003c/code\u003e is used to start a new coroutine that runs independently of the calling coroutine. It returns a \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003eJob\u003c/code\u003e object that can be used to control and cancel the coroutine. A \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003elaunch\u003c/code\u003e coroutine does not return a value.\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e\u003cli style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; display: block; margin: 0px; padding-left: 0.375em; position: relative;\"\u003e\u003cp style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; margin: 0px;\"\u003e\u003cspan style=\"background-color: white;\"\u003e\u003cspan style=\"font-family: Poppins;\"\u003e\u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003easync\u003c/code\u003e is used to start a new coroutine that runs independently of the calling coroutine and returns a \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003eDeferred\u003c/code\u003e object that represents a promise to provide a result at some point in the future. The \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003eDeferred\u003c/code\u003e object can be used to retrieve the result of the coroutine using its \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003eawait()\u003c/code\u003e function.\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\u003c/li\u003e\u003c/ul\u003e\u003cp style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: #374151; font-size: 16px; margin: 1.25em 0px; white-space: pre-wrap;\"\u003e\u003cspan style=\"background-color: white;\"\u003e\u003cspan style=\"font-family: Poppins;\"\u003eThe main difference between \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003elaunch\u003c/code\u003e and \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003easync\u003c/code\u003e is that \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003easync\u003c/code\u003e returns a value, while \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003elaunch\u003c/code\u003e does not. Therefore, \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003easync\u003c/code\u003e is typically used when you want to perform some computation in a separate coroutine and retrieve the result later, while \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003elaunch\u003c/code\u003e is used when you simply want to start a new coroutine that does not return a value.\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e",
      "author": {
        "id": "02262209569130030528",
        "displayName": "Rezaul Islam Tarek",
        "url": "https://www.blogger.com/profile/02262209569130030528",
        "image": {
          "url": "//2.bp.blogspot.com/-eGY33NWnnnw/ZywviOezqhI/AAAAAAAAV8M/KyO4eauDHZ8NTS9beS0SB_i2xwco4Uf4ACK4BGAYYCw/s35/Photoroom-20240512_215644.png"
        }
      },
      "replies": {
        "totalItems": "0",
        "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/8281872301492455126/comments"
      },
      "labels": [
        "Android",
        "Android Interview Questions",
        "async and await",
        "Coroutines",
        "Interview Questions",
        "Kotlin"
      ],
      "etag": "\"dGltZXN0YW1wOiAxNjc4NzU5MjUwMTU0Cm9mZnNldDogLTI1MjAwMDAwCg\""
    },
    {
      "kind": "blogger#post",
      "id": "7886804811378124558",
      "blog": {
        "id": "6839959377168934742"
      },
      "published": "2023-03-12T18:51:00-07:00",
      "updated": "2023-03-12T18:51:22-07:00",
      "url": "http://techinterviewpro.blogspot.com/2023/03/what-is-purpose-of-using-asyncawait-in.html",
      "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/7886804811378124558",
      "title": "What is the purpose of using async/await in Kotlin Android?",
      "content": "\u003cp\u003e\u003cspan style=\"background-color: white;\"\u003e\u003cspan style=\"font-family: Poppins;\"\u003e&nbsp;\u003cspan style=\"color: #374151; font-size: 16px; white-space: pre-wrap;\"\u003eThe purpose of using \u003c/span\u003e\u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600; white-space: pre-wrap;\"\u003easync/await\u003c/code\u003e\u003cspan style=\"color: #374151; font-size: 16px; white-space: pre-wrap;\"\u003e in Kotlin Android is to perform asynchronous operations in a more readable and manageable way than traditional callback-based approaches.\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\u003cp style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: #374151; font-size: 16px; margin: 1.25em 0px; white-space: pre-wrap;\"\u003e\u003cspan style=\"background-color: white;\"\u003e\u003cspan style=\"font-family: Poppins;\"\u003eIn Kotlin, coroutines are used to perform asynchronous operations. The \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003easync\u003c/code\u003e function creates a coroutine that runs concurrently with the rest of the application, and returns a \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003eDeferred\u003c/code\u003e object that represents the result of the coroutine. The \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003eawait\u003c/code\u003e function suspends the current coroutine until the \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003eDeferred\u003c/code\u003e object is complete, and returns the result.\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\u003cp style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: #374151; font-size: 16px; margin: 1.25em 0px; white-space: pre-wrap;\"\u003e\u003cspan style=\"background-color: white;\"\u003e\u003cspan style=\"font-family: Poppins;\"\u003eUsing \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003easync/await\u003c/code\u003e allows developers to write asynchronous code in a more sequential, easy-to-read manner, without getting bogged down in callbacks or complex state management. It also allows for better error handling and cancellation of asynchronous operations.\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e\u003cp style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: #374151; font-size: 16px; margin: 1.25em 0px 0px; white-space: pre-wrap;\"\u003e\u003cspan style=\"background-color: white;\"\u003e\u003cspan style=\"font-family: Poppins;\"\u003eIn addition, \u003ccode style=\"--tw-border-spacing-x: 0; --tw-border-spacing-y: 0; --tw-ring-color: rgba(59,130,246,0.5); --tw-ring-offset-color: #fff; --tw-ring-offset-shadow: 0 0 transparent; --tw-ring-offset-width: 0px; --tw-ring-shadow: 0 0 transparent; --tw-rotate: 0; --tw-scale-x: 1; --tw-scale-y: 1; --tw-scroll-snap-strictness: proximity; --tw-shadow-colored: 0 0 transparent; --tw-shadow: 0 0 transparent; --tw-skew-x: 0; --tw-skew-y: 0; --tw-translate-x: 0; --tw-translate-y: 0; border: 0px solid rgb(217, 217, 227); box-sizing: border-box; color: var(--tw-prose-code); font-size: 0.875em; font-weight: 600;\"\u003easync/await\u003c/code\u003e can be used to perform parallel operations, such as making multiple network requests simultaneously, and then waiting for all of them to complete before proceeding. This can result in faster overall performance and a better user experience.\u003c/span\u003e\u003c/span\u003e\u003c/p\u003e",
      "author": {
        "id": "02262209569130030528",
        "displayName": "Rezaul Islam Tarek",
        "url": "https://www.blogger.com/profile/02262209569130030528",
        "image": {
          "url": "//2.bp.blogspot.com/-eGY33NWnnnw/ZywviOezqhI/AAAAAAAAV8M/KyO4eauDHZ8NTS9beS0SB_i2xwco4Uf4ACK4BGAYYCw/s35/Photoroom-20240512_215644.png"
        }
      },
      "replies": {
        "totalItems": "0",
        "selfLink": "https://www.googleapis.com/blogger/v3/blogs/6839959377168934742/posts/7886804811378124558/comments"
      },
      "labels": [
        "Android",
        "Android Interview Questions",
        "async and await",
        "await",
        "aysnc",
        "Coroutines",
        "Interview Questions",
        "Kotlin"
      ],
      "etag": "\"dGltZXN0YW1wOiAxNjc4NjcyMjgyNzA3Cm9mZnNldDogLTI1MjAwMDAwCg\""
    }
  ],
  "etag": "\"MjAyNC0xMC0yMlQxNTowOTo0Mi43MDVa\""
}
